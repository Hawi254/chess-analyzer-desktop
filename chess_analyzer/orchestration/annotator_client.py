# chess_analyzer/orchestration/annotator_client.py
"""
Provides a client for creating and parsing PGN comments for game annotation.

This module's `AnnotatorClient` is responsible for the idempotent generation
of machine-readable analysis comments. It is designed to add new analysis
information to a PGN node's comment without destroying any pre-existing,
human-written notes. It achieves this by stripping its own previously generated
comments before adding new ones.
"""

import re
from typing import Optional, Tuple, TYPE_CHECKING

from chess_analyzer.types import MoveClassification

if TYPE_CHECKING:
    from chess_analyzer.config.settings import AnalysisSettings
    from chess_analyzer.types import (AnnotationContext, EnrichedAnalysis,
                                      FormattedEngineLine)

# Pre-compiled regex to find and extract a PGN clock tag (e.g., "[%clk 0:05:33.7]").
CLK_TAG_PATTERN = re.compile(r"(\s*\[%clk\s+.*?\]\s*)")

class AnnotatorClient:
    """A service responsible for generating and parsing PGN analysis comments."""

    def __init__(self):
        """Initializes the Annotator by pre-compiling regex patterns for comment stripping."""
        # Keywords that identify a comment as machine-generated.
        machine_keywords = ["CPL:", "Best:", "Analyse"] + [c.value for c in MoveClassification]
        pattern_str = r"\s*\{.*?(" + "|".join(re.escape(k) for k in machine_keywords) + r").*?\}\s*"
        
        self._machine_comment_strip_patterns = [
            re.compile(pattern_str, re.IGNORECASE), # For simple { [Blunder] } tags
            re.compile(r"\s*\[Analyse.*?\]\s*")    # For the detailed [Analyse ...] block
        ]

    def prepare_comment_parts(self, existing_comment: str) -> Tuple[str, str]:
        """
        Parses an existing PGN comment, separating human notes from machine tags.

        This function is key to making re-analysis idempotent. It isolates and
        preserves any text that was not generated by this application.

        Args:
            existing_comment: The raw comment string from a PGN node.

        Returns:
            A tuple containing the (user_comment, clk_tag).
        """
        if not existing_comment:
            return "", ""

        # Find and preserve the clock tag, if it exists.
        clk_match = CLK_TAG_PATTERN.search(existing_comment)
        clk_tag = clk_match.group(1).strip() if clk_match else ""
        
        # Remove the clock tag to process the rest of the comment.
        cleaned_comment = CLK_TAG_PATTERN.sub(" ", existing_comment)

        # Remove all previously machine-generated analysis comments.
        for pattern in self._machine_comment_strip_patterns:
            cleaned_comment = pattern.sub("", cleaned_comment)
        
        # What remains is assumed to be the user's original comment.
        user_comment = cleaned_comment.strip().strip("{}").strip()
        
        return user_comment, clk_tag

    def generate_pgn_node_comment(self, context: "AnnotationContext") -> str:
        """
        Generates a final, formatted PGN comment string from an analysis context.

        Args:
            context: An `AnnotationContext` object containing all necessary data.

        Returns:
            A formatted string ready to be assigned to a PGN node's `comment` attribute.
        """
        final_parts = []
        # Preserve the original user comment.
        if context.user_comment:
            final_parts.append(f"{{{context.user_comment}}}")
        
        # Preserve the original clock tag.
        if context.clk_tag:
            final_parts.append(context.clk_tag)

        # Build the simple classification tag, e.g., {[Blunder]}.
        if context.classification:
            final_parts.append(f"{{[{context.classification.value}]}}")

        # Build the detailed, multi-line analysis block, e.g.,
        # [Analyse d11 pv3: 1. e4 (+0.25) | 2. d4 (+0.30)]
        if context.engine_lines:
            header = f"[Analyse d{context.analysis_depth} pv{context.multipv_count}:"
            line_parts = [
                f"{i+1}. {line.move_san} ({line.eval_str})"
                for i, line in enumerate(context.engine_lines)
            ]
            analysis_block = f"{header} {' | '.join(line_parts)}]"
            final_parts.append(analysis_block)
        
        return " ".join(p for p in final_parts if p).strip()

def build_annotation_context(
    enriched_analysis: "EnrichedAnalysis",
    user_comment: str,
    clk_tag: Optional[str],
    settings: "AnalysisSettings",
) -> "AnnotationContext":
    """
    A factory function to build the AnnotationContext from various data sources.

    Args:
        enriched_analysis: The fully processed analysis result for a single move.
        user_comment: The preserved human-written comment.
        clk_tag: The preserved PGN clock tag.
        settings: The application's analysis settings.

    Returns:
        A populated `AnnotationContext` object.
    """
    from chess_analyzer.types import AnnotationContext

    return AnnotationContext(
        classification=enriched_analysis.classification.classification,
        centipawn_loss=enriched_analysis.classification.centipawn_loss,
        engine_lines=enriched_analysis.formatted_engine_lines,
        user_comment=user_comment,
        clk_tag=clk_tag,
        multipv_count=settings.multipv,
        analysis_depth=settings.depth,
    )